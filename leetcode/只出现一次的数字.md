## 只出现一次的数字

#### 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

---

示例 1:
输入: [2,2,1]
输出: 1

---

示例 2:
输入: [4,1,2,1,2]
输出: 4

### 我的解答
思路1：刚开始没多想，觉得排个序然后遍历下前后两个元素，如果前后2个元素相同则输出，就出来了答案了。（此解法非最优解，最优解在文章最后面）

```go
func singleNumber(nums []int) int {
    //排序下，i=1，if nums[i-1]!=nums[i]就返回nums[i-1]
    sort(nums)
    for i:=1;i<len(nums);i=i+2{
        if nums[i]!=nums[i-1]{
            return nums[i-1]
        }
    }
    //如没有那就时最后一个元素
    return nums[len(nums)-1]
    //思路2.map[int][int]
}

func sort(nums []int) {
	if len(nums) <= 1 {
		return
	}
	head, tail := 0, len(nums)-1
	key, i := nums[0], 1
	for head < tail {
		if key > nums[i] {
			nums[head], nums[i] = nums[i], nums[head]
			head++
			i++
		} else {
			nums[tail], nums[i] = nums[i], nums[tail]
			tail--
		}
	}
	nums[head] = key
	sort(nums[:head])
	sort(nums[head+1:])
}
```

#### 后来有一次同事在地铁上考我这道题，他说可以实现O（n）的复杂度，思考一会后突然灵光一闪，想起了位操作：异或 （xor ^）
#### emmmm,相信读计算机专业认真听课的小伙伴肯定知道，这里简单说下异或：

   a  |  b  | a^b|
   :---:|:---:|:---:|
   0|0|0
   0|1|1
   1|0|1
   1|1|0
   
例 如 
- 5 ^5= 00000101^00000101 = 00000000 = 0. 
- 1^2 = 00000001^00000010 = 00000011 =3.

#### 思路2：所以我们可以利用异或解答，最佳的解法是
```go
func singleNumber(nums []int) int {
    result := 0 
    for _,v := range nums{
        result ^= v
    }
    return result
}
```

